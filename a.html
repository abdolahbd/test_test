<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0,user-scalable=no"/>
  <title>Gyro Tilt Game</title>
  <style>
    /* reset & full-screen body */
    * { box-sizing: border-box; margin:0; padding:0; }
    html, body { width:100%; height:100%; overflow:hidden; background:#222; font-family:sans-serif; }

    /* playfield */
    #game {
      position: relative;
      width: 100%; height: 100%;
      background: #444;
    }

    /* the player ball */
    #ball {
      position: absolute;
      width:40px; height:40px;
      background: #e74c3c;
      border-radius: 50%;
      will-change: transform;
    }

    /* the target to catch */
    #target {
      position: absolute;
      width:30px; height:30px;
      background: #2ecc71;
      border-radius: 50%;
      will-change: transform;
    }

    /* score display */
    #score {
      position: absolute;
      top: 10px; left: 10px;
      color: #fff; font-size: 18px;
      text-shadow: 1px 1px 2px #000;
    }
  </style>
</head>
<body>
  <div id="game">
    <div id="ball"></div>
    <div id="target"></div>
    <div id="score">Score: 0</div>
  </div>

  <script>
    (() => {
      const ball = document.getElementById('ball');
      const target = document.getElementById('target');
      const scoreEl = document.getElementById('score');
      const game = document.getElementById('game');

      let width, height, rBall=20, rTarget=15;
      let pos = { x:0, y:0 };
      let orientation = { gamma:0, beta:0 };
      let score = 0;

      // update game dimensions & reset start
      function init() {
        width = game.clientWidth;
        height = game.clientHeight;
        pos.x = width/2 - rBall;
        pos.y = height/2 - rBall;
        placeTarget();
        updateScore();
      }

      // randomize target position inside bounds
      function placeTarget() {
        target.style.transform = 
          `translate(
             ${Math.random()*(width-2*rTarget)}px,
             ${Math.random()*(height-2*rTarget)}px
           )`;
      }

      // display current score
      function updateScore() {
        scoreEl.textContent = `Score: ${score}`;
      }

      // read device orientation
      window.addEventListener('deviceorientation', e => {
        // gamma: left/right tilt [-90,90], beta: front/back [-180,180]
        orientation.gamma = e.gamma || 0;
        orientation.beta  = e.beta  || 0;
      });

      // main loop
      function loop() {
        // map tilt into velocity
        const vx = orientation.gamma / 90 * 5;  // adjust sensitivity
        const vy = orientation.beta  / 90 * 5;

        pos.x += vx;
        pos.y += vy;

        // keep ball in bounds
        pos.x = Math.max(0, Math.min(pos.x, width - 2*rBall));
        pos.y = Math.max(0, Math.min(pos.y, height - 2*rBall));

        // move ball
        ball.style.transform = `translate(${pos.x}px, ${pos.y}px)`;

        // check collision with target
        const tRect = target.getBoundingClientRect();
        const bRect = ball.getBoundingClientRect();
        const dx = (bRect.left + rBall) - (tRect.left + rTarget);
        const dy = (bRect.top  + rBall) - (tRect.top  + rTarget);
        if (Math.hypot(dx, dy) < rBall + rTarget) {
          score++;
          updateScore();
          placeTarget();
        }

        requestAnimationFrame(loop);
      }

      // on resize/orientation change: re-init
      window.addEventListener('resize', init);
      window.addEventListener('orientationchange', init);

      // start everything
      init();
      loop();
    })();
  </script>
</body>
</html>
